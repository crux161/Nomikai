// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:freezed_annotation/freezed_annotation.dart' hide protected;
part 'simple.freezed.dart';

// These functions are ignored because they are not marked as `pub`: `audio_frame_tx_slot`, `clear_audio_frame_tx`, `clear_hevc_frame_tx`, `hevc_frame_tx_slot`, `install_audio_frame_tx`, `install_hevc_frame_tx`, `run_receiver_loop`, `run_sender_loop`, `send_sender_frame`, `sink_event`
// These types are ignored because they are neither used by any `pub` functions nor (for structs and enums) marked `#[frb(unignore)]`: `FrameIngressGuard`, `ReceiverRunGuard`, `SenderRunGuard`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `drop`, `drop`, `drop`, `from`

Future<void> pushVideoFrame({
  required List<int> frameBytes,
  required bool isKeyframe,
  required BigInt pts,
  required int codec,
}) => RustLib.instance.api.crateApiSimplePushVideoFrame(
  frameBytes: frameBytes,
  isKeyframe: isKeyframe,
  pts: pts,
  codec: codec,
);

Future<void> pushAudioFrame({
  required List<int> frameBytes,
  required BigInt pts,
}) => RustLib.instance.api.crateApiSimplePushAudioFrame(
  frameBytes: frameBytes,
  pts: pts,
);

Future<void> stopSankakuSender() =>
    RustLib.instance.api.crateApiSimpleStopSankakuSender();

Future<void> stopSankakuReceiver() =>
    RustLib.instance.api.crateApiSimpleStopSankakuReceiver();

/// Starts an async Sankaku sender loop and streams transport state/events to Dart.
Stream<UiEvent> startSankakuSender({
  required String dest,
  required List<int> graphBytes,
}) => RustLib.instance.api.crateApiSimpleStartSankakuSender(
  dest: dest,
  graphBytes: graphBytes,
);

/// Starts an async Sankaku receiver loop and streams transport state/events to Dart.
Stream<UiEvent> startSankakuReceiver({
  required String bindAddr,
  required List<int> graphBytes,
}) => RustLib.instance.api.crateApiSimpleStartSankakuReceiver(
  bindAddr: bindAddr,
  graphBytes: graphBytes,
);

@freezed
sealed class UiEvent with _$UiEvent {
  const UiEvent._();

  const factory UiEvent.log({required String msg}) = UiEvent_Log;
  const factory UiEvent.connectionState({
    required String state,
    required String detail,
  }) = UiEvent_ConnectionState;
  const factory UiEvent.handshakeInitiated() = UiEvent_HandshakeInitiated;
  const factory UiEvent.handshakeComplete({
    required BigInt sessionId,
    required String bootstrapMode,
  }) = UiEvent_HandshakeComplete;
  const factory UiEvent.progress({
    required int streamId,
    required BigInt frameIndex,
    required BigInt bytes,
    required BigInt frames,
  }) = UiEvent_Progress;
  const factory UiEvent.telemetry({
    required String name,
    required BigInt value,
  }) = UiEvent_Telemetry;
  const factory UiEvent.frameDrop({
    required int streamId,
    required String reason,
  }) = UiEvent_FrameDrop;
  const factory UiEvent.fault({required String code, required String message}) =
      UiEvent_Fault;
  const factory UiEvent.bitrateChanged({required int bitrateBps}) =
      UiEvent_BitrateChanged;
  const factory UiEvent.videoFrameReceived({
    required Uint8List data,
    required BigInt pts,
  }) = UiEvent_VideoFrameReceived;
  const factory UiEvent.audioFrameReceived({
    required Uint8List data,
    required BigInt pts,
  }) = UiEvent_AudioFrameReceived;
  const factory UiEvent.error({required String msg}) = UiEvent_Error;
}
